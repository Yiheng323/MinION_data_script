
# coding: utf-8

# This code is to make your life easier when you got a huge chunk of nanopore data to be basecalled separately and you want to make them into one folder again.  

# I use a certain naming system to name each chunk of my data and for each raw data I splited for basecalling I just use name_1, name_2 etc to name them. So this script does not require you to have a typical naming system but it require you to put your splited basecalled folders (unzipped) into one folder that you want to create your conbined files into, and all the splited folder are named as name_1, name_2, etc. make sure the files you put in this folder is a copy.

# In[1]:

import argparse
import os
import subprocess


# In[2]:

parser = argparse.ArgumentParser(description='This is a script to re-organize nanopore data that has been splited basecalled. It will combine everything into one folder.')
parser.add_argument("BASEDIR", help="full path for base folder, supposed to have all splited basecalled folders. remenber DO NOT put the backslash '/' at the end!")
args = parser.parse_args()


# In[39]:

# use argparse to do this
BASEDIR = args.BASEDIR
#BASEDIR = '/mnt/d/Data/reads/20180524_FAH58271_albacore231'
NAME = BASEDIR.split('/')[-1]


# In[4]:

#### unzip everthing first
if os.path.isdir(BASEDIR):
    splited_file_list = os.listdir(BASEDIR)
    for x in splited_file_list:
        if NAME not in x:
            splited_file_list.remove(x)
else:
    print("your BASEDIR is not a directory.")


# In[5]:

#if not x.endswith('tar.gz'):
#    print('files do not end with tar.gz. please check.')
#else:
#    unzip_command = 'tar -xvf *'
#    unzip_command_stderr = subprocess.check_output(unzip_command, shell=True, stderr=subprocess.STDOUT)


# In[6]:

### now let's concatenate the supplimentary files first


# In[7]:

# first let's do the sequencing_summary.txt file
os.chdir(BASEDIR)
cat_sequencing_summary_command = 'cat %s_*/sequencing_summary.txt > sequencing_summary.txt' % NAME
cat_sequencing_summary_command_stderr = subprocess.check_output(cat_sequencing_summary_command, shell=True, stderr=subprocess.STDOUT)
# done


# In[8]:

# secondly let's do the configuration.cfg file
cat_configuration_command = 'cat %s_*/configuration.cfg > configuration.cfg' % NAME
cat_configuration_command_stderr = subprocess.check_output(cat_configuration_command, shell=True, stderr=subprocess.STDOUT)
# actually what I found is that the configuration file are the same in all splited folder, which summarized some parameters used in the basecalling.
# but I just cat them together anyway


# In[9]:

# thirdly let's do the pipeline file
cat_pipeline_command = 'cat %s_*/pipeline.log > pipeline.log' % NAME
cat_pipeline_command_stderr = subprocess.check_output(cat_pipeline_command, shell=True, stderr=subprocess.STDOUT)
# done


# In[10]:

# lastly there is a sequencing_telemetry.js file generated by the newest Albacore 321 version
# I will just cut them together anyway, better to keep all the information although they are not the actual data
cat_sequencing_telemetry_command = 'cat %s_*/sequencing_telemetry.js > sequencing_telemetry.js' % NAME
cat_sequencing_telemetry_command_stderr = subprocess.check_output(cat_sequencing_telemetry_command, shell=True, stderr=subprocess.STDOUT)


# In[11]:

### OK, now let's deal with the actual data. first let's sort out structure
passed_data_dir = os.path.join(BASEDIR, 'workspace', 'pass')
failed_data_dir = os.path.join(BASEDIR, 'workspace', 'fail')
if not os.path.exists(passed_data_dir):
    os.makedirs(passed_data_dir)
if not os.path.exists(failed_data_dir):
    os.makedirs(failed_data_dir)


# In[13]:

# let's have a look at how many barcodes has been classified for passed reads
# Let's put those barcodes into a list
for x in splited_file_list:
    x_passed_data_dir = os.path.join(BASEDIR, x, 'workspace', 'pass')
    x_barcode_list = os.listdir(x_passed_data_dir)
    passed_barcode_list = []
    for y in x_barcode_list:
        passed_barcode_list.append(y)
print(passed_barcode_list)


# In[15]:

# do the same thing for failed folders
for x in splited_file_list:
    x_failed_data_dir = os.path.join(BASEDIR, x, 'workspace', 'fail')
    x_barcode_list = os.listdir(x_failed_data_dir)
    failed_barcode_list = []
    for y in x_barcode_list:
        failed_barcode_list.append(y)
print(failed_barcode_list)


# In[16]:

# now make the combined barcode folders
for i in passed_barcode_list:
    if not os.path.exists(os.path.join(passed_data_dir, i)):
        os.makedirs(os.path.join(passed_data_dir, i))
for j in failed_barcode_list:
    if not os.path.exists(os.path.join(failed_data_dir, j)):
        os.makedirs(os.path.join(failed_data_dir, j))


# In[31]:

### secondly let's take advantage from commandline to contatenate all the data together
# I would not like to use the python because it will include loops within loops. I prefer straightforward logic
# alright, let's first write the command. Should be easy right?
def cat_passed_fastq(barcode):
    for x in splited_file_list:
        y = os.path.join(x, 'workspace/pass/%s' % barcode)
        cat_passed_fastq_command = 'cat %s/*.fastq >> ./workspace/pass/%s/%s.fastq' % (y, barcode, barcode)
        print(cat_passed_fastq_command)
        try:
            cat_passed_fastq_command_stderr = subprocess.check_output(cat_passed_fastq_command, shell=True, stderr=subprocess.STDOUT)
#        except subprocess.CalledProcessError, e:
#            output = str(e.output)
#        finished = output.split('\n')
#        for line in finished:
#            print line
#        return
        except subprocess.CalledProcessError as e:
            print(e.output)
            continue


# In[32]:

# now define the failed one
def cat_failed_fastq(barcode):
    for x in splited_file_list:
        y = os.path.join(x, 'workspace/fail/%s' % barcode)
        cat_failed_fastq_command = 'cat %s/*.fastq >> ./workspace/fail/%s/%s.fastq' % (y, barcode, barcode)
        print(cat_failed_fastq_command)
        try:
            cat_failed_fastq_command_stderr = subprocess.check_output(cat_failed_fastq_command, shell=True, stderr=subprocess.STDOUT)
        except subprocess.CalledProcessError as e:
            #raise RuntimeError("command '{}' return with error (code {}): {}".format(e.cmd, e.returncode, e.output))
            print(e.output)
            continue


# In[33]:

# OK, now let's write one loop to finish all the concatenate
for e in passed_barcode_list:
    cat_passed_fastq(e)
for f in failed_barcode_list:
    cat_failed_fastq(f)


# In[34]:

# Last step, delete the splited file. Make sure you double check after generated the combined folder
deletion_command = 'rm -r ' + NAME +'_*'
print(deletion_command)
deletion_command_stderr = subprocess.check_output(deletion_command, shell=True, stderr=subprocess.STDOUT)


# In[ ]:




# In[ ]:




# In[ ]:




# In[ ]:



